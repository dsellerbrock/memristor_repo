function QSSsensobj = QSSsens(DAE, QSSsol, QSSu, parmORinputObj, parmORinputFlag)
%function QSSsensobj = QSSsens(DAE, QSSsol, QSSu, parmORinputObj, parmORinputFlag)
%This function performs QSS sensitivity analysis, both direct and adjoint. The
%analysis calculates the sensitivity of DAE state outputs to either parameters
%or inputs.
%
%INPUT args:
%   DAE              - circuit DAE.
%   QSSsol           - QSS solution for the sensitivity analysis.
%   QSSu             - QSS input for the sensitivity analysis.
%                      If the DAE doesn't require inputs, put [].
%   parmORinputObj   - parameter object or input object of the DAE.
%
%                      Note 1: It is usually generated by Parameters(DAE) or
%                      Inputs(DAE).
%                      
%                      Note 2: If it is [], all parameters or inputs are used
%                      in QSSsens.
%
%   parmORinputFlag  - (optional) a flag, either 'input' or 'parm', indicating
%                      whether parmORinputObj is an input or parameter object.
%                      If not provided, it is assumed to be 'parm'.
%
% the DAE (with noise inputs) is:
% if the flag DAE.f_takes_inputs == 0:
%
%     qdot(x, p) + f(x, p) + B*u(t) + m(x, n(t), p) = 0
%     y = C*x + D*u(t)
%
% if the flag DAE.f_takes_inputs == 1:
%
%     qdot(x, p) + f(x, u(t), p) + m(x, n(t), p) = 0
%     y = C*x + D*u(t)
%
%For QSS sensitivity analysis, we ignore the noise term m(...) and
%the qdot term.
%
%1. Parameter sensitivity:
%   After solving for a QSS steady state at some nominal p, differentiate
%   around it wrt the parameter vector p to obtain:
%
%     Gf*dx + Sf*dp= 0
%     dy = C*dx
%
%Direct sensitivity computation:
%     Sx =def= dx/dp = - Gf^{-1} Sf
%     Sy =def= dy/dp = C*Sx
%
%Adjoint sensitivity computation:
%   from above, Sy^* = Sx^* C^* = - Sf^* Gf^{-*} C^*
%   compute this as: 
%     1) z = - Gf^{-*} C^*, or Gf^* z = - C^* (sparse matrix solve)
%     2) Sy = z^* Sf
%
%2. Input sensitivity:
%   After solving for a QSS steady state at some nominal u, differentiate
%   around it wrt the input vector u to obtain:
%
%     Gf*dx + Sf*du= 0
%     dy = C*dx + D*du
%
%Direct sensitivity computation:
%     Sx =def= dx/dp = - Gf^{-1} Sf
%     Sy =def= dy/dp = C*Sx + D
%
%Adjoint sensitivity computation:
%   from above, Sy^* = Sx^* C^* = - Sf^* Gf^{-*} C^*
%   compute this as: 
%
%     1) z = - Gf^{-*} C^*, or Gf^* z = - C^* (sparse matrix solve)
%     2) Sy = z^* Sf + D
%
%Examples
%--------
% % set up DAE
% nstages = 5; VDD = 1.2; betaN = 1e-3; betaP = 1e-3; VTN = 0.25; VTP = 0.25;
% RDSN = 4500; RDSP = 4500; CL = 1e-6;
% 
% DAE = inverterchain('somename',nstages, VDD, betaN, betaP, VTN, VTP, RDSN, RDSP, CL);
% 
% % find DC solution
% uDC = 0.6;
% DAE = feval(DAE.set_uQSS, uDC, DAE);
% dcop = op(DAE);
% sol = dcop.getSolution(dcop);
% 
% % Choose subset of all parameters
% pobj = Parameters(DAE);
% % thin down the parms
% pobj = feval(pobj.Delete, {'VDD1', 'VDD2', 'VDD3', 'VDD4', 'VDD5'}, pobj);
% pobj = feval(pobj.Delete, {'CL1', 'CL2', 'CL3', 'CL4', 'CL5'}, pobj);
% 
% % Choose a single output of interest
% outs = StateOutputs(DAE);
% outs = feval(outs.DeleteAll, outs);
% lastnode = sprintf('e%d', nstages);
% outs = feval(outs.Add, {lastnode}, outs);
% 
% % QSS sensitivity setup
% SENS = QSSsens(DAE, sol, uDC, pobj);
% 
% % Direct sensitivity computation
% adjoint = 0;
% SENS = feval(SENS.solve, outs, adjoint, SENS);
% SENS.print(SENS);
% SENS.plot(SENS);
% 
% % Adjoint sensitivity computation
% adjoint = 1;
% SENS = feval(SENS.solve, outs, adjoint, SENS);
% SENS.print(SENS);
% SENS.plot(SENS);
%
%See also
%--------
%
% op, QSS, NR, analyses-algorithms, DAE_concepts, DAEAPI
%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Type "help MAPPlicense" at the MATLAB/Octave prompt to see the license      %
%% for this software.                                                          %
%% Author: J. Roychowdhury, 2008/sometime                                      %
%% Copyright (C) 2008-2020 Jaijeet Roychowdhury <jr@berkeley.edu>. All rights  %
%%               reserved.                                                     %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%Changelog:
%---------
%2016-01-28: Tianshi Wang <tianshi@berkeley.edu>: added input sensitivity,
%                     implemented print and plot, added example.
%some time ago: Jaijeet Roychowdury <jr@berkeley.edu> 
%

    % process inputs
    if (nargin > 5) | (nargin < 4)
        fprintf(2, sprintf('%s: error: too many or too few arguments.\n', QSSsensobj.name));
        help('QSSsens');
        QSSsensobj = [];
        return;
    end

    if nargin < 5
		parmORinputFlag = 'parm';
	end

	% now we have all the 5 inputs, check if parmORinputFlag is valid, set up
	% ParmObj or InputObj.

    if strcmp(parmORinputFlag, 'parm')
		ParmObj = parmORinputObj;
        QSSsensobj.ParmObj = ParmObj;
    elseif strcmp(parmORinputFlag, 'input')
		InputObj = parmORinputObj;
        QSSsensobj.InputObj = InputObj;
    else
        fprintf(2, sprintf('%s: error: parmORinputFlag has to be either ''parm'' or ''input''.\n', QSSsensobj.name));
        help('QSSsens');
        QSSsensobj = [];
        return;
    end
	QSSsensobj.parmORinputFlag = parmORinputFlag;

    % usage and name strings
    QSSsensobj.name = 'QSS Sensitivity Analysis for DAEAPIv6';
    QSSsensobj.Usage = 'Run "help QSSsens;" at MATLAB prompt';

    % precomputation and data setup
    if 0 == DAE.f_takes_inputs
        QSSsensobj.Gf = feval(DAE.df_dx, QSSsol, DAE);
    else
        QSSsensobj.Gf = feval(DAE.df_dx, QSSsol, QSSu, DAE);
    end

    QSSsensobj.DAE = DAE;
	if strcmp(parmORinputFlag, 'parm')
		%%%%%%%%%%%%%%%%%%%%%%% begin computing Sf = df/dp using vecvalder %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

		if nargin < 4 || 0 == length(ParmObj)
			nparms = feval(DAE.nparms, DAE);
			parmIndices = 1:nparms;
			parmnames = feval(DAE.parmnames, DAE);
			ParmObj = Parameters(DAE);
		else
			parmIndices = feval(ParmObj.ParmIndices, ParmObj);
			nparms = length(parmIndices);
			parmnames = feval(ParmObj.ParmNames, ParmObj);
		end

		cparms = feval(DAE.getparms, DAE);
		cparms = {cparms{parmIndices}}; % thin down to parameters of interest
		dparms = cell2mat(cparms);
		if nparms ~= size(dparms,2)
			error('test_DAEAPI_parm_derivatives: nparms ~= length of parms vector.'); 
		end
		parms = vecvalder(dparms.', speye(nparms)); % single vecvalder
		vvcparms = parms{1:nparms}; % cell array of parms as vecvalders
		DAE = feval(DAE.setparms, parmnames, vvcparms, DAE); % selected parms now set to vecvalders

		if 0 == DAE.f_takes_inputs
			vvf_of_x = feval(DAE.f, QSSsol, DAE); % vv because parms are vvs
		else
			vvf_of_x = feval(DAE.f, QSSsol, QSSu, DAE);
		end

		vv_df_dp = der2mat(vvf_of_x);
		neqns = feval(DAE.neqns, DAE);
		if size(vv_df_dp,1) < neqns || size(vv_df_dp,2) < nparms
			vv_df_dp(neqns,nparms) = 0;
		end

		QSSsensobj.Sf = vv_df_dp;
		%%%%%%%%%%%%%%%%%%%%%%% end computing Sf %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	else % if strcmp(parmORinputFlag, 'input')
		if DAE.f_takes_inputs
			df_du = DAE.df_du(QSSsol, QSSu, DAE);
		else
			df_du = DAE.B(DAE);
		end
		inputIndices = feval(InputObj.InputIndices, InputObj);
		% FIXME: truncating df_du not efficient.
		QSSsensobj.Sf = df_du(:, inputIndices);

		Dmat = DAE.D(DAE); 
		QSSsensobj.D = Dmat(:, inputIndices);
	end

    QSSsensobj.Sx = [];
    QSSsensobj.Sy = [];
    QSSsensobj.z = [];
    QSSsensobj.lastSolveType = 0; % 0=>not solved, 1=>direct, 2=>adjoint
    QSSsensobj.QSSsol = QSSsol;
    if nargin > 2
        QSSsensobj.QSSu = QSSu;
    end

    % externally callable functions
    QSSsensobj.solve = @solve; % (stateoutputs, adjoint, QSSsensobj)
    QSSsensobj.getSolution = @getSolution; % return Sx or Sy
    QSSsensobj.print = @print; % (outputsObj, QSSsensobj)
    QSSsensobj.plot = @plot; % (outputsObj, QSSsensobj) this should plot a bar chart of parameter sensitivities 
end % end of QSSsens "constructor"

function ObjOut = solve(stateoutputs, adjoint, QSSsensobj)
%function ObjOut = solve(stateoutputs, adjoint, QSSsensobj)
%This function runs noise analysis on a QSS sensitivity analyis object
%INPUT args:
%    stateoutputs        - if present and not [], compute PSDs of the outputs
%                          specified; otherwise, compute PSDs of DAE-specified
%                          outputs
%    adjoint             - if present and == 1, run adjoint noise analysis. 
%                          if absent or == 0, run direct noise analysis.
%   QSSsensobj          - QSS sensitivity analysis object
%
%OUTPUT:
%   ObjOut              - QSS sensitivity analysis object with sensitivity
%                         analysis solution

    if nargin < 2
        fprintf(2, 'QSSsens.solve: not enough arguments\n');
        help('QSSsens');
        return;
    end
    
    if 2 == nargin % (stateoutputs, QSSsensboj)
        QSSsensobj = adjoint;
        adjoint = 0;
    end

    if 1 == nargin % (QSSsensobj)
        QSSsensobj = stateoutputs;
        adjoint = 0;
        stateoutputs = [];
    end

    DAE = QSSsensobj.DAE;

    if 0 == sum(size(stateoutputs))
        % plot DAE outputs
        C = feval(DAE.C, DAE);
        QSSsensobj.onames = feval(DAE.outputnames, DAE);
    else % plot state outputs specified in stateoutputs
        % set up C, onames
        nunks = feval(DAE.nunks, DAE); 

        varidxs = feval(stateoutputs.OutputIndices, stateoutputs);
        C = sparse([]); 
        C(length(varidxs), nunks)=0;
        for i=1:length(varidxs)
            C(i,varidxs(i)) = 1; 
        end
        QSSsensobj.onames = feval(stateoutputs.OutputNames, stateoutputs);
    end

    Gf = QSSsensobj.Gf;
    Sf = QSSsensobj.Sf;

    if 0 == adjoint % direct sensitivities
        QSSsensobj.Sx = - Gf \ Sf;
        QSSsensobj.Sy = C*QSSsensobj.Sx;
		if strcmp(QSSsensobj.parmORinputFlag, 'input')
			% FIXME: 20160128 neglecting matrix D, because of the way outputs are supported now
			% QSSsensobj.Sy = QSSsensobj.Sy + QSSsensobj.D;
		end
        QSSsensobj.lastSolveType = 1; % direct
        QSSsensobj.z = []; % valid only after adjoint solve
    else % adjoint sensitivities
        QSSsensobj.z = - (Gf') \ (C');
        QSSsensobj.Sy = QSSsensobj.z' * Sf;
		if strcmp(QSSsensobj.parmORinputFlag, 'input')
			% FIXME: 20160128 neglecting matrix D, because of the way outputs are supported now
			% QSSsensobj.Sy = QSSsensobj.Sy + QSSsensobj.D;
		end
        QSSsensobj.lastSolveType = 2; % adjoint
        QSSsensobj.Sx = []; % valid only after direct solve
    end

    ObjOut = QSSsensobj;
end % end solve

function sol = getSolution(QSSsensobj)
%function sol = getSolution(QSSsensobj)
%This function gathers the noise analysis solution from a QSS sensitivity
%analysis object.
%INPUT args:
%   QSSsensobj      - QSS sensitivity analysis object
%OUTPUT:
%   sol             - solution of sensitivity analysis

    if (QSSsensobj.lastSolveType == 1)
        sol.SolutionType = 'Direct';
        sol.Sx = QSSsensobj.Sx;
        sol.Sy = QSSsensobj.Sy;
        sol.Sf = QSSsensobj.Sf;
		if strcmp(QSSsensobj.parmORinputFlag, 'parm')
			sol.ParmObj = QSSsensobj.ParmObj;
		else % if strcmp(QSSsensobj.parmORinputFlag, 'input')
        	sol.D = QSSsensobj.D;
			sol.InputObj = QSSsensobj.InputObj;
		end
    elseif (QSSsensobj.lastSolveType == 2)
        sol.SolutionType = 'Adjoint';
        sol.Sy = QSSsensobj.Sy;
        sol.z = QSSsensobj.z;
        sol.Sf = QSSsensobj.Sf;
		if strcmp(QSSsensobj.parmORinputFlag, 'parm')
			sol.ParmObj = QSSsensobj.ParmObj;
		else % if strcmp(QSSsensobj.parmORinputFlag, 'input')
        	sol.D = QSSsensobj.D;
			sol.InputObj = QSSsensobj.InputObj;
		end
    else 
        fprintf('QSSsens: run solve() first.\n');
    end
end % end of getSolution

function print(QSSsensobj)
%function print(QSSsensobj)
    if (QSSsensobj.lastSolveType == 1)
        SolutionType = 'Direct';
    elseif (QSSsensobj.lastSolveType == 2)
        SolutionType = 'Adjoint';
    else 
        fprintf('QSSsens: run solve() first.\n');
		return;
    end

	if strcmp(QSSsensobj.parmORinputFlag, 'parm')
		names = QSSsensobj.ParmObj.parmnames;
		vals = QSSsensobj.ParmObj.ParmVals(QSSsensobj.ParmObj, QSSsensobj.DAE);
	else % if strcmp(QSSsensobj.parmORinputFlag, 'input')
		names = QSSsensobj.InputObj.inputnames;
		vals = QSSsensobj.InputObj.InputVals(QSSsensobj.InputObj, QSSsensobj.DAE);
	end

	for c = 1:length(QSSsensobj.onames)
		oname = QSSsensobj.onames{c};
		fprintf('%s Sensitivities of output: %s\n', SolutionType, oname);
		fprintf('Name                 Value   Sensitivity\n');
		for d = 1:length(names)
			name = names{d};
			val = vals{d};
			spaces = repmat(' ', 1, 15-length(name)); % align values/sensitivities, works even when name is longer than 15.
			sensitivity = QSSsensobj.Sy(c, d);
			fprintf('%s%s%+.4e   %+.4e\n', name, spaces, val, full(sensitivity));
		end
		fprintf('\n');
	end
end % end QSSsens print

function plot(QSSsensobj)
%function plot(QSSsensobj)
    % TODO: for each output, make a bar chart of the nonzero sensitivities wrt the
    % given parms in decreasing order. If the max/min ratio of what's being plotted
    % is > 100 (eyeball sensitivity), use a log scale for y.
    % you can label the bar chart like this:
    % bar([3 4 5])
    % set(gca,'XTickLabel',{'me','myself','&I'}) 
    if (QSSsensobj.lastSolveType == 1)
        SolutionType = 'Direct';
    elseif (QSSsensobj.lastSolveType == 2)
        SolutionType = 'Adjoint';
    else 
        fprintf('QSSsens: run solve() first.\n');
		return;
    end

	if strcmp(QSSsensobj.parmORinputFlag, 'parm')
		names = QSSsensobj.ParmObj.parmnames;
		vals = QSSsensobj.ParmObj.ParmVals(QSSsensobj.ParmObj, QSSsensobj.DAE);
	else % if strcmp(QSSsensobj.parmORinputFlag, 'input')
		names = QSSsensobj.InputObj.inputnames;
		vals = QSSsensobj.InputObj.InputVals(QSSsensobj.InputObj, QSSsensobj.DAE);
	end

	for c = 1:length(QSSsensobj.onames)
		figure; 
		oname = QSSsensobj.onames{c};
		sensitivityVec = full(QSSsensobj.Sy(c, :));
		abssensitivityVec = abs(sensitivityVec);
		if (max(abssensitivityVec) > 1000*min(abssensitivityVec(abssensitivityVec>0)))
			hb = bar(abssensitivityVec);
			% % TODO: the several lines below are for zero entries; may not work
			% hbars = get(hb,'children');
			% verts = get(hbars,'vertices');
			% verts(verts==0) = min(abssensitivityVec)*10^-1;
			% set(hbars,'vertices', verts);
			set(gca,'yscale','log');
			title(sprintf('%s Sensitivities of output: %s (Absolute values)\n', SolutionType, oname));
		else
			bar(sensitivityVec);
			title(sprintf('%s Sensitivities of output: %s\n', SolutionType, oname));
		end
		grid on;
		set(gca,'XTick', 1:length(names));
		set(gca,'XTickLabel', names);
	end
end % end QSSsens plot
