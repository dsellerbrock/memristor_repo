function export_MOD_via_vv4(MOD, outfile_name)

    % this function attempts to "export" a ModSpec model to a file
        % the exported version of the model is supposed to be a canonical 
        % representation of the model, i.e., the file that is exported should
        % contain everything about the model.
    % an additional requirement is that this file should be easily "parseable"
        % that is, one should be able to write a simple parser that is able to 
        % read in the exported file, and translate the underlying model into a
        % variety of other languages, including C++, Python, Verilog, or even a 
        % more efficient MATLAB version with code for derivatives built-in

    % Author: Aadithya V. Karthik <aadithya@berkeley.edu>, July 2014.

    % Changelog
        % Jun 2013: Modified by Aadithya to conform to the new ModSpec API

    % parameters for the export function
    num_format = '%1.12e';

    % calculate sizes of various vectors associated with MOD
    len_vecX = 2*(length(MOD.NIL.node_names)-1) - length(MOD.explicit_output_names);
    len_vecY = length(MOD.internal_unk_names);
    len_vecU = length(MOD.u_names);
    if MOD.support_initlimiting > 0.5
        len_vecLim = length(MOD.limited_var_names);
    end

    % open outfile
    fid = fopen(outfile_name, 'w');

    %%%%%%%%%%%%%%%%%%%%%%%%%%%    HEADER COMMENTS   %%%%%%%%%%%%%%%%%%%%%%%%%%%

    fprintf(fid, '# This model file was auto-generated by export_MOD_via_vv4.\n\n');

    fprintf(fid, '# Parameters used by export_MOD_via_vv4():\n');
    fprintf(fid, ['# num_format = ', '''']);
    fprintf(fid, '%s', num_format);
    fprintf(fid, ['''', '\n']);

    fprintf(fid, '\n');

    %%%%%%%%%%%%%%%%%%%%%%    EXPORT BASIC INFORMATION    %%%%%%%%%%%%%%%%%%%%%%
    
    fprintf(fid, '[BEGIN BASIC INFO]\n\n');

    % model name
    fstr = ['MODEL_NAME = ', '''', MOD.model_name, '''', '\n'];
    fprintf(fid, fstr);

    % model description
        % Note: model description is exported as an empty string because it can 
        % be really hard to parse
    fstr = ['MODEL_DESCRIPTION = ', '''', '''', '\n'];
    fprintf(fid, fstr);

    % NOT exporting uniqID

    % terminals
    fstr = ['TERMINALS = ', cell_array_of_strings_to_string(MOD.NIL.node_names), '\n'];
    fprintf(fid, fstr);

    % reference node
    fstr = ['REFNODE = ', '''', MOD.NIL.refnode_name, '''', '\n'];
    fprintf(fid, fstr);

    % internal unks
    fstr = ['INTERNAL_UNKS = ', cell_array_of_strings_to_string(MOD.internal_unk_names), '\n'];
    fprintf(fid, fstr);

    % explicit outputs
    fstr = ['EXPLICIT_OUTS = ', cell_array_of_strings_to_string(MOD.explicit_output_names), '\n'];
    fprintf(fid, fstr);

    % implicit equations
    fstr = ['IMPLICIT_EQNS = ', cell_array_of_strings_to_string(MOD.implicit_equation_names), '\n'];
    fprintf(fid, fstr);

    % u_names
    fstr = ['INTERNAL_SRCS = ', cell_array_of_strings_to_string(MOD.u_names), '\n'];
    fprintf(fid, fstr);

    % output_names
    fstr = ['OUTPUT_NAMES = ', cell_array_of_strings_to_string(MOD.output_names), '\n'];
    fprintf(fid, fstr);

    % output_matrix
    fstr = ['\nOUTPUT_MATRIX =\n', matrix_to_string(MOD.output_matrix, num_format)];
    fprintf(fid, fstr);
    fprintf(fid, '\n');

    % support_initlimiting
    if MOD.support_initlimiting > 0.5
        s = 'True';
    else
        s = 'False';
    end
    fstr = ['SUPPORT_INITLIMITING = ', s, '\n'];
    fprintf(fid, fstr);

    fprintf(fid, '\n[END BASIC INFO]\n');

    %%%%%%%%%%%%%%%%%%%%%%%%%    EXPORT PARAMETERS    %%%%%%%%%%%%%%%%%%%%%%%%%%

    fprintf(fid, '\n[BEGIN PARAMETERS]\n\n');

    nparms = length(MOD.parm_names);
    for idx = 1:1:nparms
        parmname_str = MOD.parm_names{idx};
        parmval = MOD.parm_defaultvals{idx};
        if isfloat(parmval)
            parmval_str = num2str(parmval, num_format);
            parmtype_str = 'FLOAT';
        elseif isinteger(parmval)
            parmval_str = int2str(parmval);
            parmtype_str = 'INT';
        elseif ischar(parmval)
            parmval_str = ['''', parmval, ''''];
            parmtype_str = 'CHAR';
        elseif islogical(parmval)
            parmtype_str = 'BOOL';
            if parmval
                parmval_str = 'True';
            else
                parmval_str = 'False';
            end
        else
            error(['ERROR: Unrecognized data type for parameter ', parmname_str]);
        end
        fprintf(fid, [parmname_str,' = ', parmval_str, ' [', parmtype_str, ']', '\n']);
    end

    fprintf(fid, '\n[END PARAMETERS]\n');

    %%%%%%%%%%%%%%%%%%%%%%%    EXPORT CORE FUNCTIONS    %%%%%%%%%%%%%%%%%%%%%%%%

    fprintf(fid, '\n[BEGIN CORE FUNCTIONS]\n\n');

    % Core functions: fe, qe, fi, qi:

    fprintf(fid, '# Note: The convention for naming the independent variables is important. For\n');
    fprintf(fid, '# example, the python re-export-to-MATLAB utility assumes that vecX entries are\n');
    fprintf(fid, '# named vecX_1, vecX_2, etc., parameters are named parm_R, parm_C, etc., and so\n');
    fprintf(fid, '# on. Auto-differentiation relies on this convention being followed.\n\n');

    % fe

    % fe without limiting: fe(vecX, vecY, vecU, MOD)
    fprintf(fid, '# fe_without_limiting(vecX, vecY, vecU)\n');
    fprintf(fid, 'fe_without_limiting = \n');
    fstr = MODfunc_to_string(MOD.fe, 3, [len_vecX, len_vecY, len_vecU], {'vecX', 'vecY', 'vecU'}, num_format, MOD);
    fprintf(fid, fstr);

    % fe with limiting: fe(vecX, vecY, vecLim, vecU, MOD)
    if MOD.support_initlimiting > 0.5
        fprintf(fid, '# fe_with_limiting(vecX, vecY, vecLim, vecU)\n');
        fprintf(fid, 'fe_with_limiting = \n');
        fstr = MODfunc_to_string(MOD.fe, 4, [len_vecX, len_vecY, len_vecLim, len_vecU], {'vecX', 'vecY', 'vecLim', 'vecU'}, num_format, MOD);
        fprintf(fid, fstr);
    end

    % qe

    % qe without limiting: qe(vecX, vecY, MOD)
    fprintf(fid, '# qe_without_limiting(vecX, vecY)\n');
    fprintf(fid, 'qe_without_limiting = \n');
    fstr = MODfunc_to_string(MOD.qe, 2, [len_vecX, len_vecY], {'vecX', 'vecY'}, num_format, MOD);
    fprintf(fid, fstr);

    % qe with limiting: qe(vecX, vecY, vecLim, MOD)
    if MOD.support_initlimiting > 0.5
        fprintf(fid, '# qe_with_limiting(vecX, vecY, vecLim)\n');
        fprintf(fid, 'qe_with_limiting = \n');
        fstr = MODfunc_to_string(MOD.qe, 3, [len_vecX, len_vecY, len_vecLim], {'vecX', 'vecY', 'vecLim'}, num_format, MOD);
        fprintf(fid, fstr);
    end

    % fi

    % fi without limiting: fi(vecX, vecY, vecU, MOD)
    fprintf(fid, '# fi_without_limiting(vecX, vecY, vecU)\n');
    fprintf(fid, 'fi_without_limiting = \n');
    fstr = MODfunc_to_string(MOD.fi, 3, [len_vecX, len_vecY, len_vecU], {'vecX', 'vecY', 'vecU'}, num_format, MOD);
    fprintf(fid, fstr);

    % fi with limiting: fi(vecX, vecY, vecLim, vecU, MOD)
    if MOD.support_initlimiting > 0.5
        fprintf(fid, '# fi_with_limiting(vecX, vecY, vecLim, vecU)\n');
        fprintf(fid, 'fi_with_limiting = \n');
        fstr = MODfunc_to_string(MOD.fi, 4, [len_vecX, len_vecY, len_vecLim, len_vecU], {'vecX', 'vecY', 'vecLim', 'vecU'}, num_format, MOD);
        fprintf(fid, fstr);
    end

    % qi

    % qi without limiting: qi(vecX, vecY, MOD)
    fprintf(fid, '# qi_without_limiting(vecX, vecY)\n');
    fprintf(fid, 'qi_without_limiting = \n');
    fstr = MODfunc_to_string(MOD.qi, 2, [len_vecX, len_vecY], {'vecX', 'vecY'}, num_format, MOD);
    fprintf(fid, fstr);

    % qi with limiting: qi(vecX, vecY, vecLim, MOD)
    if MOD.support_initlimiting > 0.5
        fprintf(fid, '# qi_with_limiting(vecX, vecY, vecLim)\n');
        fprintf(fid, 'qi_with_limiting = \n');
        fstr = MODfunc_to_string(MOD.qi, 3, [len_vecX, len_vecY, len_vecLim], {'vecX', 'vecY', 'vecLim'}, num_format, MOD);
        fprintf(fid, fstr);
    end

    fprintf(fid, '[END CORE FUNCTIONS]\n\n');

    %%%%%%%%%%%%%%%%%%%%%    EXPORT INIT/LIMITING INFO    %%%%%%%%%%%%%%%%%%%%%%

    if MOD.support_initlimiting > 0.5

        fprintf(fid, '[BEGIN INIT/LIMITING]\n\n');

        % limited vars
        fstr = ['LIMITED_VARS = ', cell_array_of_strings_to_string(MOD.limited_var_names), '\n'];
        fprintf(fid, fstr);

        % vecXY_to_limitedvars_matrix
        fstr = ['\nVECXY_TO_LIMITED_VARS_MATRIX =\n', matrix_to_string(MOD.vecXY_to_limitedvars_matrix, num_format)];
        fprintf(fid, fstr);
        fprintf(fid, '\n');

        % initGuess(vecU, MOD)
        fprintf(fid, '# init_guess(vecU)\n');
        fprintf(fid, 'init_guess =\n');
        fstr = MODfunc_to_string(MOD.initGuess, 1, [len_vecU], {'vecU'}, num_format, MOD);
        fprintf(fid, fstr);

        % limiting(vecX, vecY, vecLim, vecU, MOD)
        fprintf(fid, '# limiting(vecX, vecY, vecLim, vecU)\n');
        fprintf(fid, 'limiting =\n');
        fstr = MODfunc_to_string(MOD.limiting, 4, [len_vecX, len_vecY, len_vecLim, len_vecU], {'vecX', 'vecY', 'vecLim', 'vecU'}, num_format, MOD);
        fprintf(fid, fstr);
        
        fprintf(fid, '[END INIT/LIMITING]\n');

    end

    % close outfile
    fclose(fid);

end

function out = cell_array_of_strings_to_string(cellin)

    % this function converts a cell array of strings into a single comma 
    % separated string, interpretable as a Python list

    out = '[';

    n = length(cellin);
    for idx = 1:1:n
        if idx > 1.5
            out = [out, ', '];
        end
        out = [out, '''', cellin{idx}, ''''];
    end

    out = [out, ']'];

end

function out = matrix_to_string(M, num_format)

    % this function converts a 2D numeric matrix (M) into a string (out)
        % each row of the matrix becomes a separate line
        % matrix columns are separated by spaces
    % num_format is a string that specifies how the numbers in the matrix 
    % should be formatted, e.g., '%1.12e'

    out = '';

    if isempty(M)
        return;
    end

    num_rows = size(M, 1);
    num_cols = size(M, 2);

    for row_idx = 1:1:num_rows
        for col_idx = 1:1:num_cols
            if col_idx > 1.5
                out = [out, ' '];
            end
            out = [out, num2str(M(row_idx, col_idx), num_format)];
        end
        out = [out, '\n'];
    end

end

function out = MODfunc_to_string(fhandle, nvecargs, veclengths, vecnames, num_format, MOD)

    % given the ModSpec model MOD and a function handle fhandle this function
    % encodes the operation of the function fhandle as a string. This works as
    % follows: we assume that fhandle takes nvecargs+1 arguments, of which the
    % first nvecargs arguments are vectors. The last argument is MOD itself. The
    % veclengths argument specifies the lengths of the first nvecargs vector
    % arguments to fhandle. Knowing this, we create nvecargs independent vv4
    % arrays, and pass those as inputs to fhandle instead. The operations on
    % these vv4 objects are overloaded so that one can keep precise track of
    % what the underlying function is doing, even if the function calls other
    % functions and so on. Before running the function fhandle, we also make
    % sure that MOD's parms are set to vv4 objects. In this way, a single run of
    % the function tells us everything we need, and we can export the output of
    % this run (a vv4 object that encodes all the operations carried out by
    % fhandle) into a string.

    % initialize vv4
    vv4_init();

    % replace MOD's parms with vv4 objects
    nparms = length(MOD.parm_names);
    for idx = 1:1:nparms
        parmname = MOD.parm_names{idx};
        parmval = vv4('INDEP', ['parm_', parmname]);
        MOD = feval(MOD.setparms, parmname, parmval, MOD);
    end

    % create a vv4 array for each vector argument to fhandle
    for vec_idx = 1:1:nvecargs
        vecarg_length = veclengths(1,vec_idx);
        vecarg_name = vecnames{vec_idx};
        vv4_names = {};
        for name_idx = 1:1:vecarg_length
            vv4_names = [vv4_names, [vecarg_name, '_', num2str(name_idx)]];
        end
        eval(['vecargs_', num2str(vec_idx), ' = vv4_indep_array(vecarg_length, vv4_names);']);
    end

    % build evalstr for running fhandle
    evalstr = 'fhandle_out = feval(fhandle';
    for vec_idx = 1:1:nvecargs
        evalstr = [evalstr, ', vecargs_', num2str(vec_idx)];
    end
    evalstr = [evalstr, ', MOD);'];
    
    % run fhandle once
    eval(evalstr);

    % produce a string encoding of the operations done by fhandle
    if isempty(fhandle_out)
        out = '';
    else
        out = vv4_array_to_string(fhandle_out, num_format);
    end

    % add an empty line to out to indicate the end of the string encoding
    out = [out, '\n'];

    % tear down vv4
    vv4_finish();

end

